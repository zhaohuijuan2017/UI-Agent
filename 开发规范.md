# Python代码开发规范（基于Claude Code与PEP 8）

## 1. 总则与目标

### 1.1 规范目的
本规范旨在为使用Claude Code进行Python开发的团队提供统一、明确且专业的协作标准。核心目标是通过标准化代码风格、开发流程和协作模式，显著提升团队整体生产力、代码质量和项目可维护性。

Python作为一门强调代码可读性的语言，其设计哲学"优雅胜于丑陋，明了胜于晦涩"（Zen of Python）与本规范的理念高度契合。通过执行统一标准，我们消除因风格差异导致的摩擦，使团队成员能够将注意力集中在业务逻辑实现和创新上。

### 1.2 适用范围
本规范适用于团队内所有使用Python进行开发的项目，包括但不限于：
- Web应用（Django、Flask、FastAPI）
- 数据科学与机器学习项目
- 自动化脚本与工具
- API服务与微服务
- DevOps与基础设施代码

所有团队成员在编写、审查和维护Python代码时都必须严格遵守本规范。使用Claude Code进行代码生成、重构或调试时，也应以本规范作为指导原则。

### 1.3 核心理念
- **可读性第一**：代码是写给人看的，清晰表达意图比炫技更重要
- **Pythonic优先**：遵循Python的习惯用法和最佳实践
- **一致性优于个人偏好**：统一的风格降低理解成本
- **拥抱现代Python**：积极使用类型提示、dataclass等现代特性
- **测试驱动质量**：完善的测试覆盖是代码质量的保障

## 2. 开发环境与工具配置

### 2.1 Python版本
团队统一采用 **Python 3.14+** 作为标准开发版本。Python 3.14提供了显著的性能提升和新特性：
- 更快的执行速度（比3.10快10-60%）
- 改进的错误消息
- 更好的类型提示支持
- 异常组（Exception Groups）

所有开发、测试和生产环境必须统一版本，避免兼容性问题。

### 2.2 依赖管理
推荐使用以下工具进行依赖管理：

**Poetry（推荐）**：
```bash
# 安装Poetry
curl -sSL https://install.python-poetry.org | python3 -

# 创建新项目
poetry new my-project

# 添加依赖
poetry add requests
poetry add --group dev pytest
```

**requirements.txt + pip**：
```bash
# 生产依赖
requirements.txt

# 开发依赖
requirements-dev.txt

# 安装
pip install -r requirements.txt
pip install -r requirements-dev.txt
```

### 2.3 必备开发工具

#### 2.3.1 代码格式化
**Black（强制使用）**：
```bash
# 安装
pip install black

# 使用
black .

# 配置 pyproject.toml
[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
```

**isort（导入排序）**：
```bash
pip install isort

# 配置 pyproject.toml
[tool.isort]
profile = "black"
line_length = 88
```

#### 2.3.2 代码检查
**Ruff（推荐，超快的linter）**：
```bash
pip install ruff

# 使用
ruff check .
ruff check --fix .

# 配置 pyproject.toml
[tool.ruff]
line-length = 88
select = ["E", "F", "I", "N", "W"]
ignore = ["E501"]
```

**Pylint（可选，更严格）**：
```bash
pip install pylint
pylint your_module
```

#### 2.3.3 类型检查
**mypy（强制使用）**：
```bash
pip install mypy

# 使用
mypy .

# 配置 pyproject.toml
[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

### 2.4 IDE配置
推荐使用 **VS Code** 或 **PyCharm**，并安装以下插件：

**VS Code**：
- Python
- Pylance
- Black Formatter
- isort
- mypy

**配置 .vscode/settings.json**：
```json
{
  "python.formatting.provider": "black",
  "python.linting.enabled": true,
  "python.linting.pylintEnabled": false,
  "python.linting.ruffEnabled": true,
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  }
}
```

### 2.5 Claude Code集成

#### 2.5.1 项目级配置：CLAUDE.md
在项目根目录创建 `CLAUDE.md`：

```markdown
# 项目概述
[项目名称] - [简要描述]

## 技术栈
- Python 3.11+
- Framework: FastAPI / Django / Flask
- Database: PostgreSQL / MongoDB
- ORM: SQLAlchemy / Django ORM
- Testing: pytest, pytest-cov
- Async: asyncio, aiohttp

## 代码风格
- 遵循 PEP 8 和本团队规范
- 使用 Black 格式化（88字符行宽）
- 使用 isort 排序导入
- 使用类型提示（Type Hints）
- 使用 Ruff 进行代码检查

## 命名规范
- 模块/包：lowercase_with_underscores
- 类：PascalCase
- 函数/方法/变量：snake_case
- 常量：UPPER_SNAKE_CASE
- 私有成员：_leading_underscore

## 架构原则
- 遵循SOLID原则
- 依赖注入
- 清晰的层次结构（如三层架构）
- 领域驱动设计（DDD）概念

## 测试策略
- pytest作为测试框架
- 最低80%测试覆盖率
- 使用fixtures管理测试数据
- 集成测试使用testcontainers

## 常用命令
```bash
# 安装依赖
poetry install

# 运行测试
pytest

# 代码格式化
black . && isort .

# 类型检查
mypy .

# 代码检查
ruff check .
```
```

#### 2.5.2 团队共享配置
在 `.claude/` 目录下创建分主题的配置文件：
- `team-standards.md`：团队约定
- `testing-strategy.md`：测试策略
- `api-guidelines.md`：API设计规范
- `async-patterns.md`：异步编程模式

## 3. 代码风格规范（基于PEP 8）

### 3.1 代码布局

#### 3.1.1 缩进
- 使用 **4个空格** 进行缩进，严禁使用Tab
- 续行应垂直对齐或使用悬挂缩进

```python
# 正确：垂直对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 正确：悬挂缩进
foo = long_function_name(
    var_one, var_two,
    var_three, var_four
)

# 错误：未对齐
foo = long_function_name(var_one, var_two,
    var_three, var_four)
```

#### 3.1.2 行长度
- 最大行长度：**88字符**（Black默认）
- 文档字符串和注释：**72字符**
- 长表达式应适当换行

```python
# 正确
result = some_function_that_takes_arguments(
    'a' * 100, 'b' * 100, 'c' * 100
)

# 正确：使用括号换行
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

#### 3.1.3 空行
- 顶层函数和类定义之间：**2个空行**
- 类内方法定义之间：**1个空行**
- 函数内逻辑段之间：可使用**1个空行**分隔

```python
class MyClass:
    """类文档字符串"""

    def __init__(self):
        self.value = 0

    def method_one(self):
        pass

    def method_two(self):
        pass


def top_level_function():
    pass


class AnotherClass:
    pass
```

### 3.2 导入规范

#### 3.2.1 导入顺序
导入应分为三组，用空行分隔：
1. 标准库导入
2. 第三方库导入
3. 本地应用/库导入

```python
# 标准库
import os
import sys
from typing import List, Optional

# 第三方库
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException

# 本地应用
from myapp.models import User
from myapp.services import UserService
```

#### 3.2.2 导入规则
- 每个导入独占一行（除了 `from x import a, b`）
- 避免使用通配符导入（`from module import *`）
- 使用绝对导入，避免相对导入
- 按字母顺序排序（isort自动处理）

```python
# 正确
import os
import sys

# 正确
from typing import List, Dict, Optional

# 错误
import os, sys

# 错误
from module import *
```

### 3.3 命名规范

#### 3.3.1 命名风格
| 类型 | 命名风格 | 示例 |
|------|---------|------|
| 模块/包 | lowercase | `utils.py`, `data_processor` |
| 类 | PascalCase | `UserProfile`, `OrderService` |
| 函数/方法 | snake_case | `get_user_name()`, `process_order()` |
| 变量 | snake_case | `user_count`, `max_retries` |
| 常量 | UPPER_SNAKE_CASE | `MAX_CONNECTIONS`, `API_KEY` |
| 私有成员 | _leading_underscore | `_internal_cache` |
| 特殊方法 | __dunder__ | `__init__`, `__str__` |

#### 3.3.2 命名原则
- **描述性优于简洁性**：`user_profile` 优于 `up`
- **避免单字母变量**：除了循环计数器（`i`, `j`, `k`）
- **布尔变量用is/has前缀**：`is_valid`, `has_permission`
- **避免保留字**：不要使用 `class_`, `type_` 等
- **私有但不需要名称修饰的用单下划线**：`_helper_function`

```python
# 好的命名
def calculate_total_price(items: List[Item], discount_rate: float) -> float:
    total = sum(item.price for item in items)
    return total * (1 - discount_rate)

# 不好的命名
def calc(i, d):
    t = sum(x.p for x in i)
    return t * (1 - d)
```

### 3.4 表达式和语句

#### 3.4.1 空格使用
```python
# 正确：运算符两侧有空格
x = 1
y = 2
result = x + y

# 正确：逗号后有空格
my_list = [1, 2, 3]

# 正确：冒号后有空格（字典）
my_dict = {'key': 'value'}

# 错误：不必要的空格
x=1
my_list = [1,2,3]
my_dict = { 'key' : 'value' }
```

#### 3.4.2 比较
```python
# 正确：使用 is 比较单例
if x is None:
    pass

if x is not None:
    pass

# 错误：使用 == 比较单例
if x == None:
    pass

# 正确：检查空序列
if not seq:
    pass

# 不推荐：显式比较长度
if len(seq) == 0:
    pass
```

### 3.5 注释与文档字符串

#### 3.5.1 注释原则
- 注释应解释"为什么"，而非"是什么"
- 保持注释与代码同步
- 使用完整的句子
- 行内注释与代码至少间隔2个空格

```python
# 好的注释：解释原因
# 使用LRU缓存避免重复计算斐波那契数列
@lru_cache(maxsize=None)
def fibonacci(n: int) -> int:
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 不必要的注释：重复代码
# 计算总和
total = sum(numbers)
```

#### 3.5.2 文档字符串（Docstrings）
使用 **Google风格** 或 **NumPy风格** 的文档字符串：

**Google风格**（推荐）：
```python
def calculate_discount(
    price: float,
    discount_rate: float,
    member_level: str = "standard"
) -> float:
    """计算折扣后的价格。

    根据原价、折扣率和会员等级计算最终价格。
    VIP会员可以享受额外5%的折扣。

    Args:
        price: 商品原价，必须大于0
        discount_rate: 折扣率，范围[0, 1]
        member_level: 会员等级，可选值：'standard', 'vip'

    Returns:
        折扣后的价格，保留两位小数

    Raises:
        ValueError: 当价格小于等于0或折扣率不在有效范围时

    Example:
        >>> calculate_discount(100.0, 0.2, "vip")
        72.0
    """
    if price <= 0:
        raise ValueError("价格必须大于0")
    if not 0 <= discount_rate <= 1:
        raise ValueError("折扣率必须在0到1之间")
    
    final_price = price * (1 - discount_rate)
    if member_level == "vip":
        final_price *= 0.95
    
    return round(final_price, 2)
```

**类文档字符串**：
```python
class UserRepository:
    """用户数据访问层。

    提供用户数据的CRUD操作，封装数据库访问逻辑。

    Attributes:
        db_session: SQLAlchemy数据库会话
        cache: Redis缓存客户端

    Example:
        >>> repo = UserRepository(db_session)
        >>> user = repo.get_by_id(1)
        >>> print(user.username)
    """

    def __init__(self, db_session, cache=None):
        self.db_session = db_session
        self.cache = cache
```

## 4. 现代Python编程实践

### 4.1 类型提示（Type Hints）

#### 4.1.1 基本类型提示
```python
from typing import List, Dict, Optional, Union, Tuple

# 基础类型
def greet(name: str) -> str:
    return f"Hello, {name}"

# 容器类型
def process_items(items: List[int]) -> Dict[str, int]:
    return {"count": len(items), "sum": sum(items)}

# 可选类型
def find_user(user_id: int) -> Optional[User]:
    return db.query(User).filter_by(id=user_id).first()

# 联合类型
def parse_value(value: Union[int, str, float]) -> float:
    return float(value)

# 元组
def get_coordinates() -> Tuple[float, float]:
    return (10.5, 20.3)
```

#### 4.1.2 泛型和高级类型
```python
from typing import TypeVar, Generic, Protocol, Callable

# 泛型
T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self) -> None:
        self.items: List[T] = []
    
    def push(self, item: T) -> None:
        self.items.append(item)
    
    def pop(self) -> T:
        return self.items.pop()

# 协议（结构化类型）
class Drawable(Protocol):
    def draw(self) -> None:
        ...

# 可调用类型
def apply_operation(
    value: int,
    operation: Callable[[int], int]
) -> int:
    return operation(value)
```

### 4.2 数据类（Dataclass）

```python
from dataclasses import dataclass, field
from typing import List
from datetime import datetime

@dataclass
class User:
    """用户数据模型。"""
    id: int
    username: str
    email: str
    created_at: datetime = field(default_factory=datetime.now)
    tags: List[str] = field(default_factory=list)
    is_active: bool = True

    def __post_init__(self):
        """数据验证。"""
        if not self.email or '@' not in self.email:
            raise ValueError("无效的邮箱地址")

# 使用
user = User(id=1, username="alice", email="alice@example.com")
print(user)  # 自动生成 __repr__
```

### 4.3 上下文管理器

```python
from contextlib import contextmanager
from typing import Generator

# 使用装饰器创建上下文管理器
@contextmanager
def database_transaction(session) -> Generator:
    """数据库事务上下文管理器。"""
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

# 使用
with database_transaction(session) as db:
    db.add(new_user)

# 类形式的上下文管理器
class Timer:
    """执行时间计时器。"""
    
    def __enter__(self):
        self.start = time.time()
        return self
    
    def __exit__(self, *args):
        self.end = time.time()
        self.elapsed = self.end - self.start
        print(f"执行时间: {self.elapsed:.2f}秒")

# 使用
with Timer():
    # 执行耗时操作
    process_large_dataset()
```

### 4.4 异步编程

```python
import asyncio
from typing import List

# 异步函数
async def fetch_user(user_id: int) -> User:
    """异步获取用户信息。"""
    async with aiohttp.ClientSession() as session:
        async with session.get(f"/api/users/{user_id}") as response:
            data = await response.json()
            return User(**data)

# 并发执行
async def fetch_multiple_users(user_ids: List[int]) -> List[User]:
    """并发获取多个用户信息。"""
    tasks = [fetch_user(user_id) for user_id in user_ids]
    return await asyncio.gather(*tasks)

# 异步上下文管理器
class AsyncDatabaseConnection:
    async def __aenter__(self):
        self.conn = await asyncpg.connect()
        return self.conn
    
    async def __aexit__(self, *args):
        await self.conn.close()

# 使用
async with AsyncDatabaseConnection() as conn:
    result = await conn.fetch("SELECT * FROM users")
```

### 4.5 装饰器模式

```python
from functools import wraps
import time
from typing import Callable, Any

# 基础装饰器
def timer(func: Callable) -> Callable:
    """计时装饰器。"""
    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 执行时间: {end - start:.2f}秒")
        return result
    return wrapper

# 带参数的装饰器
def retry(max_attempts: int = 3, delay: float = 1.0):
    """重试装饰器。"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"尝试 {attempt + 1} 失败: {e}")
                    time.sleep(delay)
        return wrapper
    return decorator

# 使用
@timer
@retry(max_attempts=3, delay=2.0)
def fetch_data_from_api(url: str) -> dict:
    # API调用逻辑
    pass
```

## 5. 架构与设计模式

### 5.1 依赖注入

```python
from typing import Protocol

# 定义接口
class UserRepository(Protocol):
    def get_by_id(self, user_id: int) -> Optional[User]:
        ...
    
    def save(self, user: User) -> None:
        ...

# 实现
class SQLUserRepository:
    def __init__(self, db_session):
        self.db_session = db_session
    
    def get_by_id(self, user_id: int) -> Optional[User]:
        return self.db_session.query(User).filter_by(id=user_id).first()
    
    def save(self, user: User) -> None:
        self.db_session.add(user)
        self.db_session.commit()

# 服务层依赖注入
class UserService:
    def __init__(self, user_repo: UserRepository):
        self.user_repo = user_repo
    
    def get_user(self, user_id: int) -> Optional[User]:
        return self.user_repo.get_by_id(user_id)
```

### 5.2 工厂模式

```python
from abc import ABC, abstractmethod
from enum import Enum

class PaymentMethod(Enum):
    CREDIT_CARD = "credit_card"
    PAYPAL = "paypal"
    ALIPAY = "alipay"

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount: float) -> bool:
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, amount: float) -> bool:
        # 信用卡支付逻辑
        return True

class PayPalProcessor(PaymentProcessor):
    def process_payment(self, amount: float) -> bool:
        # PayPal支付逻辑
        return True

class PaymentProcessorFactory:
    """支付处理器工厂。"""
    
    @staticmethod
    def create(method: PaymentMethod) -> PaymentProcessor:
        processors = {
            PaymentMethod.CREDIT_CARD: CreditCardProcessor,
            PaymentMethod.PAYPAL: PayPalProcessor,
        }
        processor_class = processors.get(method)
        if not processor_class:
            raise ValueError(f"不支持的支付方式: {method}")
        return processor_class()
```

### 5.3 策略模式

```python
from typing import Protocol

class DiscountStrategy(Protocol):
    """折扣策略接口。"""
    def calculate(self, price: float) -> float:
        ...

class NoDiscount:
    def calculate(self, price: float) -> float:
        return price

class PercentageDiscount:
    def __init__(self, percentage: float):
        self.percentage = percentage
    
    def calculate(self, price: float) -> float:
        return price * (1 - self.percentage)

class FixedAmountDiscount:
    def __init__(self, amount: float):
        self.amount = amount
    
    def calculate(self, price: float) -> float:
        return max(0, price - self.amount)

class PriceCalculator:
    def __init__(self, strategy: DiscountStrategy):
        self.strategy = strategy
    
    def calculate_final_price(self, original_price: float) -> float:
        return self.strategy.calculate(original_price)
```

## 6. 错误处理

### 6.1 自定义异常

```python
class ApplicationError(Exception):
    """应用程序基础异常。"""
    def __init__(self, message: str, code: str = None):
        self.message = message
        self.code = code
        super().__init__(self.message)

class ValidationError(ApplicationError):
    """数据验证异常。"""
    pass

class ResourceNotFoundError(ApplicationError):
    """资源未找到异常。"""
    pass

class UnauthorizedError(ApplicationError):
    """未授权异常。"""
    pass

# 使用
def get_user(user_id: int) -> User:
    user = db.query(User).filter_by(id=user_id).first()
    if not user:
        raise ResourceNotFoundError(
            f"用户不存在: {user_id}",
            code="USER_NOT_FOUND"
        )
    return user
```

### 6.2 错误处理最佳实践

```python
# 具体捕获异常
try:
    result = risky_operation()
except ValueError as e:
    logger.error(f"值错误: {e}")
    handle_value_error(e)
except KeyError as e:
    logger.error(f"键错误: {e}")
    handle_key_error(e)
except Exception as e:
    logger.exception("未预期的错误")
    raise

# 使用finally清理资源
file = None
try:
    file = open("data.txt")
    process_file(file)
except IOError as e:
    logger.error(f"文件操作失败: {e}")
finally:
    if file:
        file.close()

# 推荐：使用上下文管理器
try:
    with open("data.txt") as file:
        process_file(file)
except IOError as e:
    logger.error(f"文件操作失败: {e}")
```

### 6.3 日志记录

```python
import logging
from logging.handlers import RotatingFileHandler

# 配置日志
def setup_logging():
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # 文件处理器（自动轮转）
    file_handler = RotatingFileHandler(
        "app.log",
        maxBytes=10485760,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.INFO)
    
    # 格式化
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)
    
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger

# 使用
logger = setup_logging()

def process_order(order_id: int):
    logger.info(f"开始处理订单: {order_id}")
    try:
        # 处理逻辑
        logger.debug(f"订单详情: {order}")
        logger.info(f"订单处理成功: {order_id}")
    except Exception as e:
        logger.exception(f"订单处理失败: {order_id}")
        raise
```

## 7. 测试策略

### 7.1 pytest配置

**pyproject.toml**:
```toml
[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--strict-markers",
    "--cov=src",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-fail-under=80",
]
```

### 7.2 单元测试

```python
import pytest
from unittest.mock import Mock, patch

class TestUserService:
    """用户服务测试类。"""
    
    @pytest.fixture
    def user_repo(self):
        """Mock用户仓库。"""
        repo = Mock()
        return repo
    
    @pytest.fixture
    def user_service(self, user_repo):
        """用户服务实例。"""
        return