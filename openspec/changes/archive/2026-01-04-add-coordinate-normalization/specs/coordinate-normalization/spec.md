# coordinate-normalization Specification

## Purpose

定义LLM视觉API返回的归一化坐标的检测和还原机制,确保UI元素定位在不同分辨率截图下都能准确工作。

## 新增需求

### 需求：归一化坐标检测

系统**必须**能够自动检测LLM返回的坐标是否为归一化坐标。

#### 场景：检测归一化坐标

**给定**：LLM返回的边界框坐标为 `[100, 200, 300, 400]`
**并且**：截图实际尺寸为 `1920×1080`

**当**：系统解析LLM返回的坐标

**那么**：
- 系统应判断这是归一化坐标(因为最大坐标400 < 最小图像边1080)
- 系统应触发坐标转换逻辑
- 日志应输出: `[坐标] 检测到归一化坐标 (100, 200, 300, 400), 已转换为实际坐标`

#### 场景：识别像素坐标

**给定**：LLM或OCR返回的边界框坐标为 `[500, 600, 700, 800]`
**并且**：截图实际尺寸为 `800×600`

**当**：系统解析坐标

**那么**：
- 系统应判断这是像素坐标(因为坐标值接近图像尺寸)
- 系统应直接使用该坐标,不进行转换
- 日志不应输出坐标转换信息

#### 场景：边界情况 - 小尺寸图像

**给定**：截图尺寸为 `800×600`
**并且**：返回坐标为 `[400, 300, 600, 450]`

**当**：系统检测坐标类型

**那么**：
- 系统应识别为像素坐标(坐标值接近图像尺寸)
- 不应误判为归一化坐标

---

### 需求：坐标转换计算

当检测到归一化坐标时,系统**必须**将其转换为实际像素坐标。

#### 场景：标准分辨率转换 - Full HD

**给定**：截图尺寸为 `1920×1080`
**并且**：LLM返回归一化坐标 `[500, 500, 600, 600]`

**当**：执行坐标转换

**那么**：
- 转换后坐标应为 `[960, 540, 1152, 648]`
- 计算过程：
  - x1 = (500 / 1000) × 1920 = 960
  - y1 = (500 / 1000) × 1080 = 540
  - x2 = (600 / 1000) × 1920 = 1152
  - y2 = (600 / 1000) × 1080 = 648

#### 场景：标准分辨率转换 - 2K

**给定**：截图尺寸为 `2560×1440`
**并且**：LLM返回归一化坐标 `[0, 0, 500, 1000]`

**当**：执行坐标转换

**那么**：
- 转换后坐标应为 `[0, 0, 1280, 1440]`
- 计算过程：
  - x1 = (0 / 1000) × 2560 = 0
  - y1 = (0 / 1000) × 1440 = 0
  - x2 = (500 / 1000) × 2560 = 1280
  - y2 = (1000 / 1000) × 1440 = 1440

#### 场景：标准分辨率转换 - 4K

**给定**：截图尺寸为 `3840×2160`
**并且**：LLM返回归一化坐标 `[250, 250, 750, 750]`

**当**：执行坐标转换

**那么**：
- 转换后坐标应为 `[960, 540, 2880, 1620]`
- 元素中心点应为 `(1920, 1080)`

#### 场景：边界裁剪 - 超出右边界

**给定**：截图尺寸为 `1920×1080`
**并且**：LLM返回归一化坐标 `[900, 500, 1050, 600]`

**当**：执行坐标转换

**那么**：
- x2应被裁剪为 `1920`(图像宽度)
- 转换后坐标应为 `[1728, 540, 1920, 648]`
- 不应抛出异常

#### 场景：边界裁剪 - 超出左边界

**给定**：LLM返回归一化坐标包含负数 `[-50, 100, 200, 300]`

**当**：执行坐标转换

**那么**：
- x1应被裁剪为 `0`
- 转换后坐标中第一个元素应为 `0`

#### 场景：最小尺寸保证

**给定**：LLM返回的bbox宽度或高度为0(如 `[500, 500, 500, 600]`)

**当**：执行坐标转换

**那么**：
- 系统应确保bbox至少有1像素宽度和高度
- 转换后的x2应至少为x1+1
- 转换后的y2应至少为y1+1

---

### 需求：向后兼容性

坐标还原功能**必须**保持与现有代码的向后兼容性。

#### 场景：像素坐标直接使用

**给定**：OCR返回像素坐标 `[100, 200, 300, 400]`
**并且**：截图尺寸为 `1920×1080`

**当**：系统处理该坐标

**那么**：
- 检测逻辑应判断为像素坐标
- 不应执行转换
- 返回的UIElement.bbox应与输入完全相同

#### 场景：API签名不变

**给定**：现有代码调用 `VisualLocator.locate(prompt, screenshot)`

**当**：升级到新版本

**那么**：
- 方法签名不应改变
- 返回值类型不应改变
- 现有测试用例应继续通过

---

### 需求：性能要求

坐标转换**必须**满足性能要求,不影响系统整体性能。

#### 场景：转换时间开销

**给定**：单个bbox坐标转换

**当**：执行转换操作

**那么**：
- 转换时间应小于1微秒
- 不应成为性能瓶颈

#### 场景：批量转换

**给定**：LLM返回20个UI元素

**当**：批量执行坐标转换

**那么**：
- 总转换时间应小于20微秒
- 不应影响用户体验

---

### 需求：错误处理

系统**必须**妥善处理坐标转换过程中的各种异常情况。

#### 场景：无效坐标 - 空bbox

**给定**：LLM返回的bbox为空列表 `[]`

**当**：系统尝试解析坐标

**那么**：
- 应跳过该元素
- 不应抛出异常
- 应在日志中输出警告信息

#### 场景：无效坐标 - 坐标数量不足

**给定**：LLM返回的bbox只有2个值 `[100, 200]`

**当**：系统尝试解析坐标

**那么**：
- 应跳过该元素
- 不应抛出异常
- 日志应记录格式错误

#### 场景：无效坐标 - 非数字值

**给定**：LLM返回的bbox包含非数字值 `["abc", 100, 200, 300]`

**当**：系统尝试解析坐标

**那么**：
- 应捕获TypeError/ValueError
- 应跳过该元素
- 不应影响其他有效元素的处理

---

### 需求：可观测性

系统**必须**提供足够的日志信息,便于调试和问题排查。

#### 场景：坐标转换日志

**给定**：检测到归一化坐标并执行转换

**当**：转换完成

**那么**：
- 日志应输出归一化坐标值
- 日志应输出转换后的像素坐标值
- 日志应包含图像尺寸信息

**示例日志**:
```
[坐标] 检测到归一化坐标 (100, 200, 300, 400), 已转换为实际坐标 (192, 216, 576, 432), 图像尺寸: (1920, 1080)
```

#### 场景：检测失败日志

**给定**：坐标格式异常或检测逻辑不确定

**当**：发生检测失败

**那么**：
- 日志应输出警告级别信息
- 日志应包含原始坐标值和图像尺寸
- 系统应采用安全策略(如作为像素坐标处理)

---

### 需求：测试覆盖

坐标还原功能**必须**有完整的单元测试和集成测试覆盖。

#### 场景：单元测试覆盖

**给定**：新增的坐标检测和转换方法

**当**：运行单元测试

**那么**：
- 应覆盖归一化坐标检测的各种情况
- 应覆盖不同分辨率的转换
- 应覆盖边界情况(负坐标、超界坐标、零尺寸bbox)
- 应覆盖错误处理(空列表、格式错误)
- 测试覆盖率应达到100%

#### 场景：集成测试覆盖

**给定**：完整的视觉定位流程

**当**：使用真实截图和LLM API测试

**那么**：
- 应测试至少3种不同分辨率的截图
- 应验证转换后的坐标能正确定位UI元素
- 应验证点击操作能准确命中目标元素
- 测试应通过断言验证bbox位置精度

---

## 实现约束

1. **语言**: Python 3.14+
2. **依赖**: 不引入新的第三方库
3. **性能**: 单次转换 < 1微秒
4. **兼容性**: 保持API签名不变
5. **测试**: 单元测试覆盖率100%
