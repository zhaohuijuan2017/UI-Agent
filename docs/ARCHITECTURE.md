# 架构文档

本文档描述 UI-Agent 系统的整体架构、设计决策和实现细节。

## 目录

- [系统概述](#系统概述)
- [架构设计](#架构设计)
- [核心模块](#核心模块)
- [数据流](#数据流)
- [设计决策](#设计决策)
- [扩展性设计](#扩展性设计)
- 

## 系统概述

UI-Agent 是一个通过自然语言控制 IDE 的自动化系统，结合了自然语言处理、计算机视觉和 GUI 自动化技术。

### 核心能力

1. **自然语言理解** - 解析用户命令，识别操作意图和参数
2. **视觉定位** - 使用 AI 模型在屏幕上定位 UI 元素
3. **自动化执行** - 模拟鼠标和键盘操作执行命令
4. **结果验证** - 通过截图验证操作结果

### 技术栈

| 层级 | 技术 |
|------|------|
| 自然语言处理 | 智谱 GLM-4 API |
| 计算机视觉 | 智谱 GLM-4V-Flash + EasyOCR |
| GUI 自动化 | PyAutoGUI + Keyboard |
| 配置管理 | YAML + Pydantic |
| 测试框架 | Pytest |

## 架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户界面层                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │    CLI       │  │  交互式模式  │  │   批处理     │      │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
└─────────┼──────────────────┼──────────────────┼─────────────┘
          │                  │                  │
┌─────────┼──────────────────┼──────────────────┼─────────────┐
│         │              控制层 (Controller)     │              │
│  ┌──────▼──────────────────▼──────────────────▼──────┐      │
│  │              IDEController                         │      │
│  │  - 命令处理编排                                    │      │
│  │  - 错误处理和恢复                                  │      │
│  │  - 进度反馈                                        │      │
│  └──────┬──────────┬──────────┬──────────┬──────────┘      │
└─────────┼──────────┼──────────┼──────────┼─────────────────┘
          │          │          │          │
┌─────────▼──┐  ┌────▼─────┐  ┌▼────────┐  ┌▼──────────────┐
│   Parser   │  │ Locator  │  │Executor │  │ ConfigManager │
│            │  │          │  │         │  │               │
│ - 意图识别 │  │ - 视觉定位│  │-鼠标操作│  │ - 配置加载    │
│ - 参数提取 │  │ - OCR    │  │-键盘操作│  │ - 热更新      │
│ - 上下文   │  │ - 坐标校准│  │-序列编排│  │ - 验证        │
└────────────┘  └──────────┘  └─────────┘  └───────────────┘
       │              │              │              │
┌──────▼──────┐  ┌────▼─────┐  ┌────▼────┐  ┌────▼─────────┐
│  Intents    │  │ Screenshot│ │ Actions │  │    Schema     │
│             │  │           │  │         │  │              │
│ - 操作定义  │  │-屏幕捕获  │  │-点击    │  │- 数据模型    │
│ - 映射规则  │  │-区域截图  │  │-输入    │  │- 验证规则    │
│ - 别名支持  │  │-历史记录  │  │-快捷键  │  │- 默认值      │
└─────────────┘  └───────────┘  └─────────┘  └──────────────┘
       │              │              │              │
┌──────▼──────────────▼──────────────▼──────────────▼────────┐
│                   基础设施层 (Infrastructure)               │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│  │ Logger  │  │  Cache  │  │  Utils  │  │ Models  │       │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘       │
└────────────────────────────────────────────────────────────┘
       │              │              │              │
┌──────▼──────────────▼──────────────▼──────────────▼────────┐
│                      外部服务 (External)                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ GLM-4    │  │GLM-4V    │  │EasyOCR   │  │PyAutoGUI │   │
│  │(NLP)     │  │(Vision)  │  │(OCR)     │  │(GUI)     │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└────────────────────────────────────────────────────────────┘
```

## 核心模块

### 1. 命令解析器 (CommandParser)

**位置**: `src/parser/command_parser.py`

**职责**:
- 将自然语言转换为结构化命令
- 识别操作意图
- 提取操作参数

**处理流程**:
```
用户输入 → 意图分类 → 参数提取 → 上下文注入 → ParsedCommand
```

**关键方法**:
```python
def parse(self, text: str) -> ParsedCommand:
    """解析自然语言命令"""
    # 1. 清理输入
    # 2. 识别操作
    # 3. 提取参数
    # 4. 验证结果
```

### 2. 视觉定位器 (VisualLocator)

**位置**: `src/locator/visual_locator.py`

**职责**:
- 在屏幕截图中定位 UI 元素
- 使用多种定位策略
- 校准坐标偏移

**定位策略**:
1. **主要策略**: GLM-4V 视觉理解
2. **备用策略**: 区域内 OCR 精确定位
3. **回退策略**: 全图 OCR

**混合定位流程**:
```
GLM 获取大致区域
    ↓
扩展搜索区域 (+50%)
    ↓
OCR 精确定位文本
    ↓
坐标校准器应用偏移
    ↓
返回 UIElement
```

**坐标校准**:
```python
class CoordinateCalibrator:
    """处理系统显示缩放导致的坐标偏移"""
    def calibrate(self, bbox: tuple) -> tuple:
        """应用配置的偏移量"""
```

### 3. 自动化执行器 (AutomationExecutor)

**位置**: `src/automation/executor.py`

**职责**:
- 执行鼠标和键盘操作
- 编排操作序列
- 处理重试和超时

**支持的操作**:
```python
class ActionType(Enum):
    CLICK = "click"
    DOUBLE_CLICK = "double_click"
    RIGHT_CLICK = "right_click"
    TYPE = "type"
    SHORTCUT = "shortcut"
    WAIT = "wait"
    DRAG = "drag"
```

**执行流程**:
```
操作验证 → 元素检查 → 执行操作 → 等待结果 → 验证成功
```

### 4. 配置管理器 (ConfigManager)

**位置**: `src/config/config_manager.py`

**职责**:
- 加载和管理配置
- 支持配置热更新
- 验证配置格式

**配置层次**:
```
main.yaml (主配置)
    ↓
operations/pycharm.yaml (IDE 操作配置)
    ↓
OperationConfig (单个操作定义)
```

**热更新机制**:
```python
def _reload_worker(self):
    """后台线程监控文件变化"""
    while not self._stop_reload.is_set():
        if self._check_and_reload():
            # 配置已更新
            pass
        time.sleep(self._reload_interval)
```

### 5. IDE 控制器 (IDEController)

**位置**: `src/controller/ide_controller.py`

**职责**:
- 编排整个命令执行流程
- 处理错误和恢复
- 提供进度反馈

**执行流程**:
```python
async def execute_command(self, command: str) -> ExecutionResult:
    # 1. 解析命令
    parsed = self.parser.parse(command)

    # 2. 获取操作配置
    operation = self.config.get_operation(parsed.action)

    # 3. 定位 UI 元素
    elements = await self.locator.locate(operation, parsed)

    # 4. 执行操作
    await self.executor.execute_sequence(operation.actions, elements)

    # 5. 验证结果
    return self._verify_result(operation)
```

## 数据流

### 命令执行完整流程

```
┌──────────────┐
│ 用户输入命令  │
│ "双击main.py"│
└──────┬───────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ CommandParser.parse()                        │
│ - 清理输入: "双击main.py"                     │
│ - 意图识别: file_operation                   │
│ - 参数提取: filename="main.py"               │
│ → ParsedCommand(                             │
│     intent="file_operation",                 │
│     action="double_click_file",              │
│     parameters={"filename": "main.py"}       │
│   )                                          │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ ConfigManager.get_operation()                │
│ - 查找操作配置: double_click_file            │
│ → OperationConfig(                           │
│     name="double_click_file",                │
│     actions=[                                │
│       Action(type=double_click, target="0")  │
│     ],                                       │
│     visual_prompt="在截图中找到..."          │
│   )                                          │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ ScreenshotCapture.capture()                  │
│ - 捕获整个屏幕                                │
│ → PIL.Image (1920x1080)                     │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ VisualLocator.locate()                       │
│ - 调用 GLM-4V-Flash API                      │
│ - 解析返回的 JSON                            │
│ - 提取边界框坐标                             │
│ - 应用坐标校准                               │
│ → UIElement(                                 │
│     element_type="tree",                     │
│     description="文件树节点 main.py",        │
│     bbox=(89, 526, 155, 532),               │
│     confidence=0.95                          │
│   )                                          │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ AutomationExecutor.execute()                 │
│ - 计算中心点: (122, 529)                     │
│ - 调用 pyautogui.doubleClick()               │
│ → True (成功)                                │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌───────────────────────────────────────────────┐
│ ExecutionResult                              │
│ - status=SUCCESS                             │
│ - message="操作成功"                          │
└───────────────────────────────────────────────┘
```

## 设计决策

### 1. 为什么使用视觉定位而非 IDE API？

**决策**: 优先使用视觉定位

**理由**:
- ✅ **通用性强**: 不依赖特定 IDE 的 API
- ✅ **跨 IDE**: 可轻松扩展到其他 IDE
- ✅ **跨版本**: IDE 更新不影响功能
- ❌ **准确性**: 低于直接 API 调用
- ❌ **性能**: 需要网络请求

**缓解措施**:
- 混合定位策略（视觉 + OCR）
- 坐标校准系统
- 配置化的视觉提示词

### 2. 为什么使用云端 API 而非本地模型？

**决策**: 使用智谱 GLM-4 云端 API

**理由**:
- ✅ **准确性**: 比小型本地模型更准确
- ✅ **成本**: 无需本地 GPU
- ✅ **维护**: 无需模型更新
- ❌ **延迟**: 网络请求时间
- ❌ **依赖**: 需要互联网连接

**缓解措施**:
- 命令结果缓存
- 增量截图减少数据传输
- 短超时配置

### 3. 为什么使用 YAML 配置而非代码？

**决策**: 操作配置使用 YAML

**理由**:
- ✅ **可读性**: 易于理解和编辑
- ✅ **可扩展**: 添加新操作无需修改代码
- ✅ **可维护**: 非开发者也可以配置
- ❌ **类型安全**: 编译时无法检查

**缓解措施**:
- Pydantic 模型验证
- 启动时配置验证
- 详细的错误提示

## 扩展性设计

### 添加新的 IDE 支持

1. 创建新的操作配置文件：
```
config/operations/
├── pycharm.yaml
├── vscode.yaml    # 新增
└── idea.yaml      # 新增
```

2. 在配置中指定 IDE：
```yaml
ide:
  name: vscode
  config_path: config/operations/vscode.yaml
```

### 添加新的操作类型

1. 在操作配置文件中定义：
```yaml
operations:
  - name: my_custom_operation
    aliases: [自定义操作]
    intent: custom
    description: 我的自定义操作
    actions:
      - type: shortcut
        keys: ["ctrl", "shift", "x"]
```

2. 系统会自动加载和识别

### 添加新的定位策略

继承 `VisualLocator` 并实现：

```python
class MyCustomLocator(VisualLocator):
    def _locate_custom(self, operation, params):
        # 自定义定位逻辑
        pass
```

### 添加新的执行动作

扩展 `ActionType` 枚举：

```python
class ActionType(Enum):
    # ... 现有动作
    MY_ACTION = "my_action"
```

在 `AutomationExecutor` 中实现处理逻辑。

## 性能考虑

### 优化策略

1. **截图缓存**: 避免重复截图
2. **API 结果缓存**: 缓存常用命令的结果
3. **增量截图**: 只捕获变化的区域（未来实现）
4. **异步处理**: 并行执行独立操作

### 性能指标

| 指标 | 目标值 | 当前值 |
|------|--------|--------|
| 命令解析 | < 100ms | ~50ms |
| UI 定位 | < 3s | ~2s |
| 操作执行 | < 1s | ~0.5s |
| 端到端延迟 | < 5s | ~3s |

## 安全考虑

### 潜在风险

1. **误操作**: 自动化可能执行错误操作
2. **API 泄露**: 配置文件可能包含敏感信息
3. **无限循环**: 错误的配置可能导致死循环

### 安全措施

1. **操作确认**: 危险操作需要用户确认
2. **密钥保护**: 支持环境变量和 .env 文件
3. **超时保护**: 所有操作都有超时限制
4. **紧急停止**: Ctrl+C 可随时中断

## 未来改进

### 短期 (1-3 个月)

- [ ] 支持更多 IDE (VS Code, IntelliJ IDEA)
- [ ] 改进 OCR 准确性
- [ ] 添加操作录制功能
- [ ] 优化网络请求性能

### 中期 (3-6 个月)

- [ ] 本地模型支持（降低延迟）
- [ ] 操作学习系统（记住用户偏好）
- [ ] 多显示器支持
- [ ] 云端配置同步

### 长期 (6+ 个月)

- [ ] 插件系统
- [ ] Web UI
- [ ] 团队协作功能
- [ ] 跨平台移动端控制
